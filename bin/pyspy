#!/usr/bin/python

#############################################################################
# --raw-node-state version
#############################################################################

from subprocess import check_output
import argparse
import json
import sys

parser = argparse.ArgumentParser(description='Spy on slurm usage.')
parser.add_argument(
        '--raw-node-stats', action='store_const',
        const='raw_node_stats', default=False,
        help='Report this node stats as JSON string. Used internally.')

args = parser.parse_args()

if args.raw_node_stats:

    result = check_output(
            [
                'nvidia-smi',
                '--query-gpu=utilization.memory,utilization.gpu',
                '--format=noheader,csv'
            ]
    )

    gpu_stats = []
    gpu = 0
    for line in result.split('\n'):
        if line == '':
            continue
        tokens = line.split(',')
        mem_percent = float(tokens[0][:-1])
        gpu_percent = float(tokens[1][:-1])
        gpu_stats.append({
            'gpu':gpu,
            'mem_percent':mem_percent,
            'gpu_percent':gpu_percent
        })
        gpu += 1

    result = check_output(
            [
                'docker',
                'ps',
                '--no-trunc=true'
            ]
    )

    lines = result.split('\n')
    idx_id = lines[0].find('CONTAINER')
    idx_image = lines[0].find('IMAGE')
    idx_command = lines[0].find('COMMAND')
    idx_created = lines[0].find('CREATED')
    idx_status = lines[0].find('STATUS')
    idx_ports = lines[0].find('PORTS')
    idx_names = lines[0].find('NAMES')

    docker_stats = []
    for line in lines[1:]:
        docker_stats.append({
            'container_id': line[idx_id:idx_image].strip(),
            'image': line[idx_image:idx_command].strip(),
            'command': line[idx_command:idx_created].strip(),
            'created': line[idx_created:idx_status].strip(),
            'status': line[idx_status:idx_ports].strip(),
            'ports': line[idx_ports:idx_names].strip(),
            'names': line[idx_names:].strip(),
        })

    stats = { 'gpu_stats': gpu_stats, 'docker_stats': docker_stats }
    print json.dumps(stats)

    sys.exit(0)

#############################################################################
# default spy version
#############################################################################

try:
    import Queue
except:
    import queue as Queue
import curses
import getpass
import multiprocessing
import os
import paramiko
import time

nodes = ['slowpoke1', 'slowpoke2', 'slowpoke3', 'slowpoke4']
spy_command = os.path.abspath(__file__)

class Spy:

    def __init__(self):

        self.screen = curses.initscr()
        self.screen.nodelay(1)
        self.screen.keypad(1)
        curses.start_color()
        curses.curs_set(0)
        curses.noecho()

        self.connections = {}
        self.status_queue = multiprocessing.Queue(100)
        self.status = "Started"
        self.node_status_queues = { node: multiprocessing.Queue(10) for node in nodes }
        self.node_status = { node: {'text': "[unknown]"} for node in nodes }

        self.stop = multiprocessing.Event()
        self.update_node_status_workers = { node: multiprocessing.Process(target=self.__get_node_infos, args=(node,)) for node in nodes }
        self.stop.clear()
        for node, worker in self.update_node_status_workers.items():
            worker.start()

    def update_status(self, status):
        self.status_queue.put(status)

    def main_loop(self):

        while True:

            self.redraw()

            char = self.screen.getch()
            if char == curses.ERR:
                time.sleep(0.1)
                continue

            if char == curses.KEY_UP or char == ord('k'):
                self.status = "Up key pressed"
            if char == curses.KEY_DOWN or char == ord('j'):
                self.status = "Down key pressed"
            if char == ord('q'):
                break
            if char == ord('e'):
                raise RuntimeException("Blarg...")

    def redraw(self):

        self.screen.erase()

        # node status
        self.__update_node_status()
        i = 0
        for node in nodes:
            status = self.node_status[node]
            self.__draw_node_status(node, status, 3,i*30)
            i += 1

        # global status
        self.__update_status()
        self.screen.addstr(curses.LINES - 1, 0, self.status)

        self.screen.refresh()

    def teardown(self):

        self.stop.set()
        curses.endwin()
        for node, worker in self.update_node_status_workers.items():
            worker.join()

    def __draw_node_status(self, node, status, y, x):

        col_width = 10

        if 'text' in status:

            self.screen.addstr(y, x, node + ": " + status['text'])

        elif 'node_stats' in status:

            stats = status['node_stats']

            # GPU usage

            self.screen.addstr(y, x, '#GPU'.ljust(col_width) + 'Mem %'.ljust(col_width) + 'GPU %'.ljust(col_width))

            for gpu_stats in stats['gpu_stats']:

                gpu = gpu_stats['gpu']
                mem_percent = gpu_stats['mem_percent']
                gpu_percent = gpu_stats['gpu_percent']
                self.screen.addstr(y + gpu + 1, x,
                        str(gpu).ljust(col_width) +
                        str(mem_percent).ljust(col_width) +
                        str(gpu_percent).ljust(col_width)
                )


    def __update_status(self):

        while not self.status_queue.empty():
            self.status = self.status_queue.get()

    def __update_node_status(self):

        for node in nodes:

            # get the most recent node status
            status = None
            while not self.node_status_queues[node].empty():
                status = self.node_status_queues[node].get()
            if status is None:
                continue

            self.node_status[node] = status

    def __get_node_infos(self, node):

        parent_pid = os.getppid()

        self.node_status_queues[node].put({'text': "connecting..."})
        connection = paramiko.SSHClient()
        connection.load_system_host_keys()
        connection.set_missing_host_key_policy(paramiko.AutoAddPolicy())
        connection.connect(node)
        self.connections[node] = connection
        self.node_status_queues[node].put({'text': "connected"})

        while not self.stop.is_set():

            if os.getppid() != parent_pid:
                logger.error("parent died, shutting down")
                break

            self.update_status("calling " + spy_command + " on " + node)
            stdin, stdout, stderr = connection.exec_command(spy_command + ' --raw-node-stats')
            result = ''.join([l for l in stdout ])

            try:
                result = json.loads(result)
                self.node_status_queues[node].put({'node_stats': result})
            except:
                self.node_status_queues[node].put({'text': "Couldn't deserialize " + result})
                raise

        connection.close()

if __name__ == "__main__":

    spy = Spy()
    try:
        spy.main_loop()
    except:
        spy.teardown()
        raise
    spy.teardown()
